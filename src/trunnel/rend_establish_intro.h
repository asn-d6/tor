/* rend_establish_intro.h -- generated by by Trunnel v1.4.4.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_REND_ESTABLISH_INTRO_H
#define TRUNNEL_REND_ESTABLISH_INTRO_H

#include <stdint.h>
#include "trunnel.h"

#define SHA3_256_MAC_LEN 32
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_EXTENSION)
struct extension_st {
  uint8_t field_type;
  uint8_t field_len;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) field;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct extension_st extension_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_REND_ESTABLISH_INTRO)
struct rend_establish_intro_st {
  const uint8_t *start_cell;
  uint8_t auth_key_type;
  uint8_t auth_key_len;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) auth_key;
  uint8_t n_extensions;
  TRUNNEL_DYNARRAY_HEAD(, struct extension_st *) extensions;
  const uint8_t *end_mac_fields;
  uint8_t handshake_sha3_256[SHA3_256_MAC_LEN];
  uint8_t siglen;
  const uint8_t *end_sig_fields;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) sig;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct rend_establish_intro_st rend_establish_intro_t;
/** Return a newly allocated extension with all elements set to zero.
 */
extension_t *extension_new(void);
/** Release all storage held by the extension in 'victim'. (Do nothing
 * if 'victim' is NULL.)
 */
void extension_free(extension_t *victim);
/** Try to parse a extension from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * extension_t. On failure, return -2 if the input appears truncated,
 * and -1 if the input is otherwise invalid.
 */
ssize_t extension_parse(extension_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * extension in 'obj'. On failure, return a negative value. Note that
 * this value may be an overestimate, and can even be an underestimate
 * for certain unencodeable objects.
 */
ssize_t extension_encoded_len(const extension_t *obj);
/** Try to encode the extension from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t extension_encode(uint8_t *output, size_t avail, const extension_t *input);
/** Check whether the internal state of the extension in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *extension_check(const extension_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int extension_clear_errors(extension_t *obj);
/** Return the value of the field_type field of the extension_t in
 * 'inp'
 */
uint8_t extension_get_field_type(extension_t *inp);
/** Set the value of the field_type field of the extension_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int extension_set_field_type(extension_t *inp, uint8_t val);
/** Return the value of the field_len field of the extension_t in
 * 'inp'
 */
uint8_t extension_get_field_len(extension_t *inp);
/** Set the value of the field_len field of the extension_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int extension_set_field_len(extension_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the field field of
 * the extension_t in 'inp'.
 */
size_t extension_getlen_field(const extension_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * field of the extension_t in 'inp'.
 */
uint8_t extension_get_field(extension_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * field of the extension_t in 'inp', so that it will hold the value
 * 'elt'.
 */
int extension_set_field(extension_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field field of the
 * extension_t in 'inp'.
 */
int extension_add_field(extension_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field field of
 * 'inp'.
 */
uint8_t * extension_getarray_field(extension_t *inp);
/** Change the length of the variable-length array field field of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int extension_setlen_field(extension_t *inp, size_t newlen);
/** Return a newly allocated rend_establish_intro with all elements
 * set to zero.
 */
rend_establish_intro_t *rend_establish_intro_new(void);
/** Release all storage held by the rend_establish_intro in 'victim'.
 * (Do nothing if 'victim' is NULL.)
 */
void rend_establish_intro_free(rend_establish_intro_t *victim);
/** Try to parse a rend_establish_intro from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated rend_establish_intro_t. On failure, return -2 if the
 * input appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t rend_establish_intro_parse(rend_establish_intro_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * rend_establish_intro in 'obj'. On failure, return a negative value.
 * Note that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t rend_establish_intro_encoded_len(const rend_establish_intro_t *obj);
/** Try to encode the rend_establish_intro from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t rend_establish_intro_encode(uint8_t *output, size_t avail, const rend_establish_intro_t *input);
/** Check whether the internal state of the rend_establish_intro in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *rend_establish_intro_check(const rend_establish_intro_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int rend_establish_intro_clear_errors(rend_establish_intro_t *obj);
/** Return the position for start_cell when we parsed this object
 */
const uint8_t * rend_establish_intro_get_start_cell(const rend_establish_intro_t *inp);
/** Return the value of the auth_key_type field of the
 * rend_establish_intro_t in 'inp'
 */
uint8_t rend_establish_intro_get_auth_key_type(rend_establish_intro_t *inp);
/** Set the value of the auth_key_type field of the
 * rend_establish_intro_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int rend_establish_intro_set_auth_key_type(rend_establish_intro_t *inp, uint8_t val);
/** Return the value of the auth_key_len field of the
 * rend_establish_intro_t in 'inp'
 */
uint8_t rend_establish_intro_get_auth_key_len(rend_establish_intro_t *inp);
/** Set the value of the auth_key_len field of the
 * rend_establish_intro_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int rend_establish_intro_set_auth_key_len(rend_establish_intro_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the auth_key field
 * of the rend_establish_intro_t in 'inp'.
 */
size_t rend_establish_intro_getlen_auth_key(const rend_establish_intro_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * auth_key of the rend_establish_intro_t in 'inp'.
 */
uint8_t rend_establish_intro_get_auth_key(rend_establish_intro_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * auth_key of the rend_establish_intro_t in 'inp', so that it will
 * hold the value 'elt'.
 */
int rend_establish_intro_set_auth_key(rend_establish_intro_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field auth_key of
 * the rend_establish_intro_t in 'inp'.
 */
int rend_establish_intro_add_auth_key(rend_establish_intro_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field auth_key of
 * 'inp'.
 */
uint8_t * rend_establish_intro_getarray_auth_key(rend_establish_intro_t *inp);
/** Change the length of the variable-length array field auth_key of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int rend_establish_intro_setlen_auth_key(rend_establish_intro_t *inp, size_t newlen);
/** Return the value of the n_extensions field of the
 * rend_establish_intro_t in 'inp'
 */
uint8_t rend_establish_intro_get_n_extensions(rend_establish_intro_t *inp);
/** Set the value of the n_extensions field of the
 * rend_establish_intro_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int rend_establish_intro_set_n_extensions(rend_establish_intro_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the extensions
 * field of the rend_establish_intro_t in 'inp'.
 */
size_t rend_establish_intro_getlen_extensions(const rend_establish_intro_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * extensions of the rend_establish_intro_t in 'inp'.
 */
struct extension_st * rend_establish_intro_get_extensions(rend_establish_intro_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * extensions of the rend_establish_intro_t in 'inp', so that it will
 * hold the value 'elt'. Free the previous value, if any.
 */
int rend_establish_intro_set_extensions(rend_establish_intro_t *inp, size_t idx, struct extension_st * elt);
/** As rend_establish_intro_set_extensions, but does not free the
 * previous value.
 */
int rend_establish_intro_set0_extensions(rend_establish_intro_t *inp, size_t idx, struct extension_st * elt);
/** Append a new element 'elt' to the dynamic array field extensions
 * of the rend_establish_intro_t in 'inp'.
 */
int rend_establish_intro_add_extensions(rend_establish_intro_t *inp, struct extension_st * elt);
/** Return a pointer to the variable-length array field extensions of
 * 'inp'.
 */
struct extension_st * * rend_establish_intro_getarray_extensions(rend_establish_intro_t *inp);
/** Change the length of the variable-length array field extensions of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int rend_establish_intro_setlen_extensions(rend_establish_intro_t *inp, size_t newlen);
/** Return the position for end_mac_fields when we parsed this object
 */
const uint8_t * rend_establish_intro_get_end_mac_fields(const rend_establish_intro_t *inp);
/** Return the (constant) length of the array holding the
 * handshake_sha3_256 field of the rend_establish_intro_t in 'inp'.
 */
size_t rend_establish_intro_getlen_handshake_sha3_256(const rend_establish_intro_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * handshake_sha3_256 of the rend_establish_intro_t in 'inp'.
 */
uint8_t rend_establish_intro_get_handshake_sha3_256(const rend_establish_intro_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * handshake_sha3_256 of the rend_establish_intro_t in 'inp', so that
 * it will hold the value 'elt'.
 */
int rend_establish_intro_set_handshake_sha3_256(rend_establish_intro_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the SHA3_256_MAC_LEN-element array field
 * handshake_sha3_256 of 'inp'.
 */
uint8_t * rend_establish_intro_getarray_handshake_sha3_256(rend_establish_intro_t *inp);
/** Return the value of the siglen field of the rend_establish_intro_t
 * in 'inp'
 */
uint8_t rend_establish_intro_get_siglen(rend_establish_intro_t *inp);
/** Set the value of the siglen field of the rend_establish_intro_t in
 * 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int rend_establish_intro_set_siglen(rend_establish_intro_t *inp, uint8_t val);
/** Return the position for end_sig_fields when we parsed this object
 */
const uint8_t * rend_establish_intro_get_end_sig_fields(const rend_establish_intro_t *inp);
/** Return the length of the dynamic array holding the sig field of
 * the rend_establish_intro_t in 'inp'.
 */
size_t rend_establish_intro_getlen_sig(const rend_establish_intro_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * sig of the rend_establish_intro_t in 'inp'.
 */
uint8_t rend_establish_intro_get_sig(rend_establish_intro_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * sig of the rend_establish_intro_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int rend_establish_intro_set_sig(rend_establish_intro_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field sig of the
 * rend_establish_intro_t in 'inp'.
 */
int rend_establish_intro_add_sig(rend_establish_intro_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field sig of 'inp'.
 */
uint8_t * rend_establish_intro_getarray_sig(rend_establish_intro_t *inp);
/** Change the length of the variable-length array field sig of 'inp'
 * to 'newlen'.Fill extra elements with 0. Return 0 on success; return
 * -1 and set the error code on 'inp' on failure.
 */
int rend_establish_intro_setlen_sig(rend_establish_intro_t *inp, size_t newlen);


#endif
